<template color="#de3900" prev="true" next="true" help="https://github.com/adamabr00/Adam-s-Verge3D-tools/tree/main" tooltip="Press Shift+F to open enhanced search with tab navigation. Find blocks across all tabs with keyboard shortcuts.">
    <dummy>
        <label>Improved Search (Shift+F)</label>
    </dummy>
</template>

<script>
function code(block) {
    return `(function() {
        const params = new URLSearchParams(window.location.search);
        if (!params.has('logic') || !window.__PE__) {
            console.log('%c[Improved Search] Missing logic parameter or __PE__ not available', 'color: orange; font-weight: bold;');
            return;
        }

        let searchOverlay = null, searchInput, statusLabel, tabsBar, hintsLabel;
        let groupedResults = [], activeTabIndex = 0, currentIndexInTab = 0;
        let lastHighlightedId = null;
        let cachedBlocks = [];
        let searchTimeout = null;
        let highlightOverlay = null;
        let highlightAnimationId = null;
        const DEBOUNCE_DELAY = 250; // milliseconds - wait 250ms after user stops typing

        // ðŸ”¹ Normalize for search
        function normalize(str) {
            return (str || "").toLowerCase().replace(/[^a-z0-9]/g, '');
        }

        // ðŸ”¹ Refresh block cache (only top-level processed directly)
        function refreshBlockCache() {
            const parser = new DOMParser();
            const dom = parser.parseFromString(__PE__.generateXMLStr(), 'application/xml');
            const tabs = Array.from(dom.querySelectorAll('tab'));
            cachedBlocks = [];

            return tabs.map((tab, tabIndex) => {
                const tabName = tab.getAttribute('name') || 'Unknown';
                const blocks = [];
                tab.querySelectorAll(':scope > block').forEach(block => processBlock(block, tabName, tabIndex));
                return { tabName, tabIndex, blocks };
            });
        }

        // ðŸ”¹ Process one block and its children (no duplicate text)
        function processBlock(block, tabName, tabIndex) {
            const type = block.getAttribute('type') || '';
            const children = Array.from(block.children || []);

            // direct <field> only
            const fields = children
                .filter(el => el.tagName === 'field')
                .map(f => f.textContent.trim().toLowerCase())
                .join(' ');

            // mutation name (for procedure calls etc.)
            const mutation = children.find(el => el.tagName === 'mutation');
            const mutationName = mutation?.getAttribute('name')?.toLowerCase() || '';

            // block text = type + fields + mutation.name only
            const ownText = [type, fields, mutationName].filter(Boolean).join(' ');

            const obj = { tabName, tabIndex, id: block.getAttribute('id'), type, text: ownText };
            cachedBlocks.push(obj);

            // process children recursively, but without adding their text to the parent
            const childBlocks = block.querySelectorAll(':scope > value > block, :scope > statement > block, :scope > next > block');
            Array.from(childBlocks).forEach(child => processBlock(child, tabName, tabIndex));
        }

        // ðŸ”¹ Perform search
        function performSearch(query) {
            const nq = normalize(query);
            const allTabs = refreshBlockCache();
            groupedResults = [];

            allTabs.forEach(tab => {
                const matches = cachedBlocks.filter(b => b.tabIndex === tab.tabIndex && normalize(b.text).includes(nq));
                if (matches.length) groupedResults.push({ tabName: tab.tabName, tabIndex: tab.tabIndex, results: matches });
            });

            activeTabIndex = 0;
            currentIndexInTab = 0;
            renderTabsBar();
            // Don't auto-jump - let user navigate with arrow keys or Enter
        }

        // ðŸ”¹ Create search UI
        function createSearchUI(initialQuery = "") {
            if (searchOverlay) return;

            // Create main overlay container
            searchOverlay = document.createElement('div');
            Object.assign(searchOverlay.style, {
                position: 'fixed', top: '20px', right: '20px', zIndex: 9999,
                width: 'min(480px, 90vw)', padding: '15px',
                borderRadius: '18px',
                background: 'linear-gradient(180deg, #101827bf, #0b1324cc)',
                border: '1px solid #ffffff22',
                boxShadow: '0 20px 40px rgba(2, 6, 23, .45)',
                backdropFilter: 'blur(10px) saturate(120%)',
                color: '#e5e7eb',
                fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial'
            });

            // Create header
            const header = document.createElement('div');
            header.style.marginBottom = '18px';
            
            const title = document.createElement('h1');
            title.textContent = 'Search Puzzles';
            Object.assign(title.style, {
                fontSize: 'clamp(18px, 2.2vw, 18px)',
                lineHeight: '1.25',
                margin: '0 0 6px',
                fontWeight: '700'
            });
            
            const subtitle = document.createElement('p');
            subtitle.textContent = 'Find blocks across all tabs';
            Object.assign(subtitle.style, {
                margin: '0',
                color: '#94a3b8',
                fontSize: '14px'
            });
            
            header.appendChild(title);
            header.appendChild(subtitle);

            // Create search field with modern styling
            const fieldContainer = document.createElement('div');
            Object.assign(fieldContainer.style, {
                position: 'relative',
                border: '1px solid #ffffff1a',
                borderRadius: '14px',
                background: 'linear-gradient(180deg, #0c1322, #0a111e)',
                boxShadow: 'inset 0 0 0 1px #00000040',
                marginBottom: '5px'
            });

            searchInput = document.createElement('input');
            Object.assign(searchInput.style, {
                width: '100%',
                padding: '10px',
                border: '0',
                outline: 'none',
                background: 'transparent',
                color: '#e6f0ff',
                fontSize: '16px',
                fontFamily: '"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace',
                fontWeight: '500'
            });
            searchInput.type = 'text';
            searchInput.placeholder = 'Search puzzles...';
            searchInput.value = initialQuery;

            // Create tabs bar with modern styling
            tabsBar = document.createElement('div');
            Object.assign(tabsBar.style, {
                display: 'flex',
                gap: '8px',
                marginBottom: '12px',
                fontSize: '13px',
                flexWrap: 'wrap'
            });

            // Create status label with modern styling
            statusLabel = document.createElement('div');
            Object.assign(statusLabel.style, {
                fontSize: '13px',
                color: '#94a3b8',
                marginBottom: '8px'
            });

            // Create keyboard hints label
            hintsLabel = document.createElement('div');
            Object.assign(hintsLabel.style, {
                fontSize: '12px',
                color: '#64748b',
                marginTop: '8px',
                paddingTop: '8px',
                borderTop: '1px solid #ffffff1a',
                display: 'flex',
                gap: '12px',
                flexWrap: 'wrap',
                alignItems: 'center'
            });
            
            // Create hint items
            const createHintItem = (keys, description) => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.gap = '6px';
                
                const keysEl = document.createElement('div');
                keysEl.textContent = keys;
                Object.assign(keysEl.style, {
                    fontFamily: '"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace',
                    fontSize: '11px',
                    padding: '2px 6px',
                    borderRadius: '4px',
                    background: 'rgba(255, 255, 255, 0.08)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    color: '#cbd5e1'
                });
                
                const descEl = document.createElement('span');
                descEl.textContent = description;
                descEl.style.color = '#94a3b8';
                
                item.appendChild(keysEl);
                item.appendChild(descEl);
                return item;
            };
            
            hintsLabel.appendChild(createHintItem('â†‘â†“', 'Navigate results'));
            hintsLabel.appendChild(createHintItem('â†â†’', 'Switch tabs'));
            hintsLabel.appendChild(createHintItem('Enter', 'Jump to block'));
            hintsLabel.appendChild(createHintItem('Esc', 'Close'));

            // Create close button as X in upper right corner
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = 'Ã—';
            Object.assign(closeBtn.style, {
                position: 'absolute',
                top: '16px',
                right: '16px',
                width: '32px',
                height: '32px',
                appearance: 'none',
                border: 'none',
                borderRadius: '50%',
                background: 'rgba(255, 255, 255, 0.1)',
                color: '#94a3b8',
                fontSize: '20px',
                fontWeight: '300',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                transition: 'all .2s ease',
                zIndex: '1'
            });
            closeBtn.onclick = closeSearchUI;
            closeBtn.onmouseenter = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                closeBtn.style.color = '#e5e7eb';
            };
            closeBtn.onmouseleave = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                closeBtn.style.color = '#94a3b8';
            };

            // Assemble the UI
            fieldContainer.appendChild(searchInput);
            
            searchOverlay.appendChild(closeBtn);
            searchOverlay.appendChild(header);
            searchOverlay.appendChild(fieldContainer);
            searchOverlay.appendChild(tabsBar);
            searchOverlay.appendChild(statusLabel);
            searchOverlay.appendChild(hintsLabel);
            
            document.body.appendChild(searchOverlay);

            // Debounced search input - only search after user stops typing
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    doSearch();
                }, DEBOUNCE_DELAY);
            });
            searchInput.addEventListener('keydown', e => handleKeys(e));
            searchInput.focus();

            if (initialQuery) doSearch();
        }

        // ðŸ”¹ Render tabs bar
        function renderTabsBar() {
            tabsBar.innerHTML = '';
            groupedResults.forEach((tab, i) => {
                const el = document.createElement('div');
                el.textContent = (i === activeTabIndex)
                    ? \`\${tab.tabName} \${currentIndexInTab + 1}/\${tab.results.length}\`
                    : \`\${tab.tabName} (\${tab.results.length})\`;
                Object.assign(el.style, {
                    cursor: 'pointer',
                    padding: '8px 12px',
                    borderRadius: '10px',
                    fontSize: '13px',
                    fontWeight: '500',
                    transition: 'all .2s ease',
                    background: (i === activeTabIndex) 
                        ? 'linear-gradient(180deg, #1e293b, #334155)' 
                        : 'linear-gradient(180deg, #0e1729, #0a1323)',
                    border: (i === activeTabIndex) 
                        ? '1px solid #5b8cff' 
                        : '1px solid #ffffff22',
                    color: (i === activeTabIndex) ? '#e6f0ff' : '#94a3b8'
                });
                el.onclick = () => { activeTabIndex = i; currentIndexInTab = 0; jumpToCurrent(); renderTabsBar(); };
                el.onmouseenter = () => {
                    if (i !== activeTabIndex) {
                        el.style.filter = 'brightness(1.1)';
                    }
                };
                el.onmouseleave = () => {
                    if (i !== activeTabIndex) {
                        el.style.filter = 'brightness(1)';
                    }
                };
                tabsBar.appendChild(el);
            });

            statusLabel.textContent = groupedResults.length
                ? \`Found \${groupedResults.reduce((sum, tab) => sum + tab.results.length, 0)} results across \${groupedResults.length} tab\${groupedResults.length > 1 ? 's' : ''}\`
                : 'No results found';
        }

        // ðŸ”¹ Navigation
        function handleKeys(e) {
            if (!groupedResults.length) return;
            if (e.key === 'ArrowUp') { cycleInTab(-1); e.preventDefault(); }
            if (e.key === 'ArrowDown') { cycleInTab(1); e.preventDefault(); }
            if (e.key === 'ArrowLeft') { switchTab(-1); e.preventDefault(); }
            if (e.key === 'ArrowRight') { switchTab(1); e.preventDefault(); }
            if (e.key === 'Enter') { jumpToCurrent(); e.preventDefault(); }
        }

        function cycleInTab(dir) {
            const tab = groupedResults[activeTabIndex];
            currentIndexInTab = (currentIndexInTab + dir + tab.results.length) % tab.results.length;
            jumpToCurrent(); renderTabsBar();
        }

        function switchTab(dir) {
            activeTabIndex = (activeTabIndex + dir + groupedResults.length) % groupedResults.length;
            currentIndexInTab = 0;
            jumpToCurrent(); renderTabsBar();
        }

        // ðŸ”¹ Enhanced highlighting with custom visual effects
        function addCustomHighlight(block) {
            removeCustomHighlight();
            
            if (!block || !block.rendered) return;
            
            const svgRoot = block.getSvgRoot && block.getSvgRoot();
            if (!svgRoot) return;
            
            const workspace = Blockly.getMainWorkspace();
            if (!workspace) return;
            
            // Get block position and size
            const pos = block.getRelativeToSurfaceXY();
            const size = block.getHeightWidth();
            const scale = workspace.scale || 1;
            
            // Create a group element that will be positioned relative to the block
            const highlightGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            highlightGroup.setAttribute('id', '__searchHighlightGroup__');
            highlightGroup.setAttribute('transform', \`translate(\${pos.x}, \${pos.y})\`);
            
            // Create overlay rectangle (positioned relative to group)
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', '-6');
            rect.setAttribute('y', '-6');
            rect.setAttribute('width', String(size.width + 12));
            rect.setAttribute('height', String(size.height + 12));
            rect.setAttribute('rx', '6');
            rect.setAttribute('ry', '6');
            rect.setAttribute('fill', 'rgba(91, 140, 255, 0.15)');
            rect.setAttribute('stroke', '#5b8cff');
            rect.setAttribute('stroke-width', String(Math.max(3, 4 / scale)));
            rect.setAttribute('stroke-dasharray', '10,5');
            rect.setAttribute('opacity', '1');
            rect.setAttribute('pointer-events', 'none');
            rect.style.filter = 'drop-shadow(0 0 8px #5b8cff) drop-shadow(0 0 4px #5b8cff)';
            rect.style.vectorEffect = 'non-scaling-stroke';
            
            highlightGroup.appendChild(rect);
            
            // Get block canvas and add highlight group
            const blockCanvas = workspace.getCanvas && workspace.getCanvas();
            if (blockCanvas) {
                blockCanvas.appendChild(highlightGroup);
                highlightOverlay = highlightGroup;
                
                // Animate the highlight (pulsing effect)
                let pulseDirection = -1;
                let currentOpacity = 1;
                const pulseSpeed = 0.06;
                
                function animatePulse() {
                    if (!rect || !rect.parentNode) {
                        if (highlightAnimationId) {
                            cancelAnimationFrame(highlightAnimationId);
                            highlightAnimationId = null;
                        }
                        return;
                    }
                    
                    currentOpacity += pulseDirection * pulseSpeed;
                    
                    if (currentOpacity <= 0.4) {
                        currentOpacity = 0.4;
                        pulseDirection = 1;
                    } else if (currentOpacity >= 1) {
                        currentOpacity = 1;
                        pulseDirection = -1;
                    }
                    
                    rect.setAttribute('opacity', String(currentOpacity));
                    highlightAnimationId = requestAnimationFrame(animatePulse);
                }
                
                // Start animation
                animatePulse();
            }
        }
        
        function removeCustomHighlight() {
            if (highlightAnimationId) {
                cancelAnimationFrame(highlightAnimationId);
                highlightAnimationId = null;
            }
            
            if (highlightOverlay && highlightOverlay.parentNode) {
                highlightOverlay.parentNode.removeChild(highlightOverlay);
                highlightOverlay = null;
            }
        }

        // ðŸ”¹ Highlight the current result
        function jumpToCurrent() {
            const tab = groupedResults[activeTabIndex];
            if (!tab) return;
            const r = tab.results[currentIndexInTab];
            if (!r) return;

            const headers = document.querySelectorAll('.title-bar__tab-header');
            if (headers[r.tabIndex]) headers[r.tabIndex].click();

            setTimeout(() => {
                searchInput.focus();
                const ws = Blockly.getMainWorkspace();
                const b = ws.getBlockById(r.id);
                if (!b) return;
                
                // Check if block is inside a collapsed parent
                let blockToHighlight = b;
                let parent = b.getParent && b.getParent();
                
                // Traverse up the parent chain to find the first collapsed parent
                while (parent) {
                    if (typeof parent.isCollapsed === 'function' && parent.isCollapsed()) {
                        // Found a collapsed parent - highlight it instead
                        blockToHighlight = parent;
                        break;
                    }
                    parent = parent.getParent && parent.getParent();
                }
                
                // Remove previous custom highlight
                removeCustomHighlight();
                
                // Highlight and center on the appropriate block (parent if collapsed, otherwise the found block)
                ws.centerOnBlock(blockToHighlight.id);
                ws.highlightBlock(blockToHighlight.id);
                
                // Add enhanced custom highlight
                addCustomHighlight(blockToHighlight);
                
                lastHighlightedId = blockToHighlight.id;
            }, 10);
        }

        function doSearch() {
            const query = searchInput.value.trim();
            if (!query) { groupedResults = []; renderTabsBar(); statusLabel.textContent = '0 results'; return; }
            performSearch(query);
        }

        function closeSearchUI() {
            if (searchOverlay) {
                // Clear any pending search timeout
                clearTimeout(searchTimeout);
                searchTimeout = null;
                
                // Remove custom highlight
                removeCustomHighlight();
                
                searchOverlay.remove(); searchOverlay = null;
                groupedResults = [];
                if (lastHighlightedId) { 
                    Blockly.getMainWorkspace().highlightBlock(null); 
                    lastHighlightedId = null; 
                }
            }
        }

        function toggleSearchUI(initialQuery = "") {
            refreshBlockCache(); 
            createSearchUI(initialQuery);
        }

        // ðŸ”¹ Debug helper
        window.inspectSelectedBlockCache = function() {
            if (!cachedBlocks.length) refreshBlockCache();
            if (!Blockly.selected) return console.warn("[Search] No block selected.");
            const found = cachedBlocks.find(b => b.id === Blockly.selected.id);
            found ? console.log("[Search] Cached object for selected block:", found)
                  : console.warn("[Search] Selected block not found in cache.");
        };

        function getCleanBlockQuery(block) {
            return block?.type?.toLowerCase() || "";
        }

        // ðŸ”¹ Hotkeys
        document.addEventListener('keydown', e => {
            // âœ… Only toggle if focus is NOT inside an input/textarea
            const isTyping = document.activeElement && 
                            (document.activeElement.tagName === 'INPUT' || 
                            document.activeElement.tagName === 'TEXTAREA');

            if (!isTyping && e.shiftKey && e.key.toLowerCase() === 'f') {
                toggleSearchUI(Blockly.selected ? getCleanBlockQuery(Blockly.selected) : "");
                e.preventDefault();
            }

            if (e.key === 'Escape') closeSearchUI();
        });
    })();`;
}
</script>
