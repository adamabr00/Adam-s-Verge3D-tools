<template color="#de3900" prev="true" next="true" help="https://github.com/adamabr00/Adam-s-Verge3D-tools/tree/main" tooltip="Press Shift+F to open enhanced search with tab navigation. Find blocks across all tabs with keyboard shortcuts.">
    <dummy>
        <label>Improved Search (Shift+F)</label>
    </dummy>
</template>

<script>
function code(block) {
    return `(function() {
        const params = new URLSearchParams(window.location.search);
        if (!params.has('logic') || !window.__PE__) {
            console.log('%c[Improved Search] Missing logic parameter or __PE__ not available', 'color: orange; font-weight: bold;');
            return;
        }

        let searchOverlay = null, searchInput, statusLabel, tabsBar;
        let groupedResults = [], activeTabIndex = 0, currentIndexInTab = 0;
        let lastHighlightedId = null;
        let cachedBlocks = [];
        let searchTimeout = null;
        const DEBOUNCE_DELAY = 250; // milliseconds - wait 250ms after user stops typing

        // ðŸ”¹ Normalize for search
        function normalize(str) {
            return (str || "").toLowerCase().replace(/[^a-z0-9]/g, '');
        }

        // ðŸ”¹ Refresh block cache (only top-level processed directly)
        function refreshBlockCache() {
            const parser = new DOMParser();
            const dom = parser.parseFromString(__PE__.generateXMLStr(), 'application/xml');
            const tabs = Array.from(dom.querySelectorAll('tab'));
            cachedBlocks = [];

            return tabs.map((tab, tabIndex) => {
                const tabName = tab.getAttribute('name') || 'Unknown';
                const blocks = [];
                tab.querySelectorAll(':scope > block').forEach(block => processBlock(block, tabName, tabIndex));
                return { tabName, tabIndex, blocks };
            });
        }

        // ðŸ”¹ Process one block and its children (no duplicate text)
        function processBlock(block, tabName, tabIndex) {
            const type = block.getAttribute('type') || '';
            const children = Array.from(block.children || []);

            // direct <field> only
            const fields = children
                .filter(el => el.tagName === 'field')
                .map(f => f.textContent.trim().toLowerCase())
                .join(' ');

            // mutation name (for procedure calls etc.)
            const mutation = children.find(el => el.tagName === 'mutation');
            const mutationName = mutation?.getAttribute('name')?.toLowerCase() || '';

            // block text = type + fields + mutation.name only
            const ownText = [type, fields, mutationName].filter(Boolean).join(' ');

            const obj = { tabName, tabIndex, id: block.getAttribute('id'), type, text: ownText };
            cachedBlocks.push(obj);

            // process children recursively, but without adding their text to the parent
            const childBlocks = block.querySelectorAll(':scope > value > block, :scope > statement > block, :scope > next > block');
            Array.from(childBlocks).forEach(child => processBlock(child, tabName, tabIndex));
        }

        // ðŸ”¹ Perform search
        function performSearch(query) {
            const nq = normalize(query);
            const allTabs = refreshBlockCache();
            groupedResults = [];

            allTabs.forEach(tab => {
                const matches = cachedBlocks.filter(b => b.tabIndex === tab.tabIndex && normalize(b.text).includes(nq));
                if (matches.length) groupedResults.push({ tabName: tab.tabName, tabIndex: tab.tabIndex, results: matches });
            });

            activeTabIndex = 0;
            currentIndexInTab = 0;
            renderTabsBar();
            // Don't auto-jump - let user navigate with arrow keys or Enter
        }

        // ðŸ”¹ Create search UI
        function createSearchUI(initialQuery = "") {
            if (searchOverlay) return;

            // Create main overlay container
            searchOverlay = document.createElement('div');
            Object.assign(searchOverlay.style, {
                position: 'fixed', top: '20px', right: '20px', zIndex: 9999,
                width: 'min(480px, 90vw)', padding: '15px',
                borderRadius: '18px',
                background: 'linear-gradient(180deg, #101827bf, #0b1324cc)',
                border: '1px solid #ffffff22',
                boxShadow: '0 20px 40px rgba(2, 6, 23, .45)',
                backdropFilter: 'blur(10px) saturate(120%)',
                color: '#e5e7eb',
                fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial'
            });

            // Create header
            const header = document.createElement('div');
            header.style.marginBottom = '18px';
            
            const title = document.createElement('h1');
            title.textContent = 'Search Puzzles';
            Object.assign(title.style, {
                fontSize: 'clamp(18px, 2.2vw, 18px)',
                lineHeight: '1.25',
                margin: '0 0 6px',
                fontWeight: '700'
            });
            
            const subtitle = document.createElement('p');
            subtitle.textContent = 'Find blocks across all tabs';
            Object.assign(subtitle.style, {
                margin: '0',
                color: '#94a3b8',
                fontSize: '14px'
            });
            
            header.appendChild(title);
            header.appendChild(subtitle);

            // Create search field with modern styling
            const fieldContainer = document.createElement('div');
            Object.assign(fieldContainer.style, {
                position: 'relative',
                border: '1px solid #ffffff1a',
                borderRadius: '14px',
                background: 'linear-gradient(180deg, #0c1322, #0a111e)',
                boxShadow: 'inset 0 0 0 1px #00000040',
                marginBottom: '5px'
            });

            searchInput = document.createElement('input');
            Object.assign(searchInput.style, {
                width: '100%',
                padding: '10px',
                border: '0',
                outline: 'none',
                background: 'transparent',
                color: '#e6f0ff',
                fontSize: '16px',
                fontFamily: '"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace',
                fontWeight: '500'
            });
            searchInput.type = 'text';
            searchInput.placeholder = 'Search puzzles...';
            searchInput.value = initialQuery;

            // Create tabs bar with modern styling
            tabsBar = document.createElement('div');
            Object.assign(tabsBar.style, {
                display: 'flex',
                gap: '8px',
                marginBottom: '12px',
                fontSize: '13px',
                flexWrap: 'wrap'
            });

            // Create status label with modern styling
            statusLabel = document.createElement('div');
            Object.assign(statusLabel.style, {
                fontSize: '13px',
                color: '#94a3b8',
                marginBottom: '0px'
            });

            // Create close button as X in upper right corner
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = 'Ã—';
            Object.assign(closeBtn.style, {
                position: 'absolute',
                top: '16px',
                right: '16px',
                width: '32px',
                height: '32px',
                appearance: 'none',
                border: 'none',
                borderRadius: '50%',
                background: 'rgba(255, 255, 255, 0.1)',
                color: '#94a3b8',
                fontSize: '20px',
                fontWeight: '300',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                transition: 'all .2s ease',
                zIndex: '1'
            });
            closeBtn.onclick = closeSearchUI;
            closeBtn.onmouseenter = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                closeBtn.style.color = '#e5e7eb';
            };
            closeBtn.onmouseleave = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                closeBtn.style.color = '#94a3b8';
            };

            // Assemble the UI
            fieldContainer.appendChild(searchInput);
            
            searchOverlay.appendChild(closeBtn);
            searchOverlay.appendChild(header);
            searchOverlay.appendChild(fieldContainer);
            searchOverlay.appendChild(tabsBar);
            searchOverlay.appendChild(statusLabel);
            
            document.body.appendChild(searchOverlay);

            // Debounced search input - only search after user stops typing
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    doSearch();
                }, DEBOUNCE_DELAY);
            });
            searchInput.addEventListener('keydown', e => handleKeys(e));
            searchInput.focus();

            if (initialQuery) doSearch();
        }

        // ðŸ”¹ Render tabs bar
        function renderTabsBar() {
            tabsBar.innerHTML = '';
            groupedResults.forEach((tab, i) => {
                const el = document.createElement('div');
                el.textContent = (i === activeTabIndex)
                    ? \`\${tab.tabName} \${currentIndexInTab + 1}/\${tab.results.length}\`
                    : \`\${tab.tabName} (\${tab.results.length})\`;
                Object.assign(el.style, {
                    cursor: 'pointer',
                    padding: '8px 12px',
                    borderRadius: '10px',
                    fontSize: '13px',
                    fontWeight: '500',
                    transition: 'all .2s ease',
                    background: (i === activeTabIndex) 
                        ? 'linear-gradient(180deg, #1e293b, #334155)' 
                        : 'linear-gradient(180deg, #0e1729, #0a1323)',
                    border: (i === activeTabIndex) 
                        ? '1px solid #5b8cff' 
                        : '1px solid #ffffff22',
                    color: (i === activeTabIndex) ? '#e6f0ff' : '#94a3b8'
                });
                el.onclick = () => { activeTabIndex = i; currentIndexInTab = 0; jumpToCurrent(); renderTabsBar(); };
                el.onmouseenter = () => {
                    if (i !== activeTabIndex) {
                        el.style.filter = 'brightness(1.1)';
                    }
                };
                el.onmouseleave = () => {
                    if (i !== activeTabIndex) {
                        el.style.filter = 'brightness(1)';
                    }
                };
                tabsBar.appendChild(el);
            });

            statusLabel.textContent = groupedResults.length
                ? \`Found \${groupedResults.reduce((sum, tab) => sum + tab.results.length, 0)} results across \${groupedResults.length} tab\${groupedResults.length > 1 ? 's' : ''}\`
                : 'No results found';
        }

        // ðŸ”¹ Navigation
        function handleKeys(e) {
            if (!groupedResults.length) return;
            if (e.key === 'ArrowUp') { cycleInTab(-1); e.preventDefault(); }
            if (e.key === 'ArrowDown') { cycleInTab(1); e.preventDefault(); }
            if (e.key === 'ArrowLeft') { switchTab(-1); e.preventDefault(); }
            if (e.key === 'ArrowRight') { switchTab(1); e.preventDefault(); }
            if (e.key === 'Enter') { jumpToCurrent(); e.preventDefault(); }
        }

        function cycleInTab(dir) {
            const tab = groupedResults[activeTabIndex];
            currentIndexInTab = (currentIndexInTab + dir + tab.results.length) % tab.results.length;
            jumpToCurrent(); renderTabsBar();
        }

        function switchTab(dir) {
            activeTabIndex = (activeTabIndex + dir + groupedResults.length) % groupedResults.length;
            currentIndexInTab = 0;
            jumpToCurrent(); renderTabsBar();
        }

        // ðŸ”¹ Highlight the current result
        function jumpToCurrent() {
            const tab = groupedResults[activeTabIndex];
            if (!tab) return;
            const r = tab.results[currentIndexInTab];
            if (!r) return;

            const headers = document.querySelectorAll('.title-bar__tab-header');
            if (headers[r.tabIndex]) headers[r.tabIndex].click();

            setTimeout(() => {
                searchInput.focus();
                const ws = Blockly.getMainWorkspace();
                const b = ws.getBlockById(r.id);
                if (!b) return;
                
                // Check if block is inside a collapsed parent
                let blockToHighlight = b;
                let parent = b.getParent && b.getParent();
                
                // Traverse up the parent chain to find the first collapsed parent
                while (parent) {
                    if (typeof parent.isCollapsed === 'function' && parent.isCollapsed()) {
                        // Found a collapsed parent - highlight it instead
                        blockToHighlight = parent;
                        break;
                    }
                    parent = parent.getParent && parent.getParent();
                }
                
                // Highlight and center on the appropriate block (parent if collapsed, otherwise the found block)
                ws.centerOnBlock(blockToHighlight.id);
                ws.highlightBlock(blockToHighlight.id);
                lastHighlightedId = blockToHighlight.id;
            }, 10);
        }

        function doSearch() {
            const query = searchInput.value.trim();
            if (!query) { groupedResults = []; renderTabsBar(); statusLabel.textContent = '0 results'; return; }
            performSearch(query);
        }

        function closeSearchUI() {
            if (searchOverlay) {
                // Clear any pending search timeout
                clearTimeout(searchTimeout);
                searchTimeout = null;
                
                searchOverlay.remove(); searchOverlay = null;
                groupedResults = [];
                if (lastHighlightedId) { Blockly.getMainWorkspace().highlightBlock(null); lastHighlightedId = null; }
            }
        }

        function toggleSearchUI(initialQuery = "") {
            refreshBlockCache(); 
            createSearchUI(initialQuery);
        }

        // ðŸ”¹ Debug helper
        window.inspectSelectedBlockCache = function() {
            if (!cachedBlocks.length) refreshBlockCache();
            if (!Blockly.selected) return console.warn("[Search] No block selected.");
            const found = cachedBlocks.find(b => b.id === Blockly.selected.id);
            found ? console.log("[Search] Cached object for selected block:", found)
                  : console.warn("[Search] Selected block not found in cache.");
        };

        function getCleanBlockQuery(block) {
            return block?.type?.toLowerCase() || "";
        }

        // ðŸ”¹ Hotkeys
        document.addEventListener('keydown', e => {
            // âœ… Only toggle if focus is NOT inside an input/textarea
            const isTyping = document.activeElement && 
                            (document.activeElement.tagName === 'INPUT' || 
                            document.activeElement.tagName === 'TEXTAREA');

            if (!isTyping && e.shiftKey && e.key.toLowerCase() === 'f') {
                toggleSearchUI(Blockly.selected ? getCleanBlockQuery(Blockly.selected) : "");
                e.preventDefault();
            }

            if (e.key === 'Escape') closeSearchUI();
        });
    })();`;
}
</script>
