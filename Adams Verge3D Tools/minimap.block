<template color="#de3900" prev="true" next="true" help="https://github.com/adamabr00/Adam-s-Verge3D-tools/tree/main" tooltip="Adds a draggable minimap panel to navigate large workspaces. Shows all blocks and current viewport position.">
    <dummy>
        <label>Add Minimap</label>
    </dummy>
</template>

<script>
function code(block) {
    return `(function() {
  let currentWorkspace = null;
  let minimapInstance = null;

  function waitForBlockly() {
    if (window.Blockly && Blockly.getMainWorkspace()) {
      setupWorkspaceWatcher();
    } else {
      setTimeout(waitForBlockly, 300);
    }
  }

  // ðŸ”¥ Watch for workspace changes (tab switches)
  function setupWorkspaceWatcher() {
    const checkWorkspace = () => {
      const ws = Blockly.getMainWorkspace();
      if (ws && ws !== currentWorkspace) {
        currentWorkspace = ws;
        initProMinimap(ws);
      }
    };
    setInterval(checkWorkspace, 500); // lightweight polling
    checkWorkspace();
  }

  // Storage key for minimap state
  const MINIMAP_STORAGE_KEY = '__minimap_state';
  
  // Load saved minimap state
  function loadMinimapState() {
    try {
      const saved = localStorage.getItem(MINIMAP_STORAGE_KEY);
      if (saved) {
        return JSON.parse(saved);
      }
    } catch (e) {
      console.warn('[Minimap] Failed to load saved state:', e);
    }
    // Default values
    return {
      width: 240,
      height: 180,
      left: null,
      top: null,
      bottom: 10,
      right: 10,
      collapsed: false
    };
  }
  
  // Save minimap state
  function saveMinimapState(state) {
    try {
      localStorage.setItem(MINIMAP_STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn('[Minimap] Failed to save state:', e);
    }
  }

  function injectUI() {
    // Save state from previous minimap before removing it
    const old = document.getElementById('minimap-container');
    if (old) {
      const rect = old.getBoundingClientRect();
      const parent = old.parentElement;
      const parentRect = parent.getBoundingClientRect();
      
      // Calculate position relative to parent
      const relativeLeft = rect.left - parentRect.left;
      const relativeTop = rect.top - parentRect.top;
      
      // Check if using absolute positioning (left/top) or relative (bottom/right)
      const computedStyle = window.getComputedStyle(old);
      const hasLeft = computedStyle.left !== 'auto' && computedStyle.left !== '';
      const hasTop = computedStyle.top !== 'auto' && computedStyle.top !== '';
      const hasBottom = computedStyle.bottom !== 'auto' && computedStyle.bottom !== '';
      const hasRight = computedStyle.right !== 'auto' && computedStyle.right !== '';
      
      // Check if collapsed
      const canvas = old.querySelector('#minimap-canvas');
      const isCollapsed = canvas && canvas.style.display === 'none';
      
      saveMinimapState({
        width: old.offsetWidth,
        height: old.offsetHeight,
        left: hasLeft ? relativeLeft : null,
        top: hasTop ? relativeTop : null,
        bottom: hasBottom ? parseFloat(computedStyle.bottom) : null,
        right: hasRight ? parseFloat(computedStyle.right) : null,
        collapsed: isCollapsed
      });
      
      old.remove();
    }

    // Load saved state
    const savedState = loadMinimapState();
    const originalWidth = savedState.width || 240;
    const originalHeight = savedState.height || 180;
    
    // Build position styles
    let positionStyles = '';
    if (savedState.left !== null && savedState.top !== null) {
      positionStyles = \`left: \${savedState.left}px; top: \${savedState.top}px; right: auto; bottom: auto;\`;
    } else {
      positionStyles = \`bottom: \${savedState.bottom || 10}px; right: \${savedState.right || 10}px; left: auto; top: auto;\`;
    }
    
    const container = document.createElement('div');
    container.id = "minimap-container";
    container.style.cssText = \`
      position: absolute;
      \${positionStyles}
      width: \${originalWidth}px;
      height: \${savedState.collapsed ? '20px' : originalHeight + 'px'};
      min-width: 150px;
      min-height: 50px;
      border: 1px solid #666;
      background: #111;
      opacity: 0.9;
      z-index: 9999;
      resize: both;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      user-select: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    \`;

    // Top bar for dragging
    const topBar = document.createElement('div');
    topBar.style.cssText = \`
      height: 20px;
      background: #222;
      color: #fff;
      font-size: 12px;
      line-height: 20px;
      padding-left: 5px;
      cursor: move;
      flex-shrink: 0;
    \`;
    topBar.textContent = "ðŸ—ºï¸ Minimap";
    container.appendChild(topBar);

    // Canvas
    const canvas = document.createElement('canvas');
    canvas.id = "minimap-canvas";
    canvas.width = originalWidth;
    canvas.height = originalHeight - 20; // Subtract top bar height
    canvas.style.flex = "1";
    canvas.style.minHeight = "30px";
    container.appendChild(canvas);

    // Resize handle indicator (visual feedback)
    const resizeHandle = document.createElement('div');
    resizeHandle.style.cssText = \`
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      background: linear-gradient(-45deg, transparent 30%, #666 30%, #666 35%, transparent 35%, transparent 65%, #666 65%, #666 70%, transparent 70%);
      cursor: nwse-resize;
      pointer-events: none;
      z-index: 1;
    \`;
    container.appendChild(resizeHandle);

    // Collapse button
    const collapseBtn = document.createElement('div');
    collapseBtn.textContent = "â–¼";
    collapseBtn.style.cssText = \`
      position: absolute;
      top: 2px;
      right: 5px;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
      padding: 2px 4px;
    \`;
    collapseBtn.onmouseover = () => collapseBtn.style.background = "rgba(255,255,255,0.1)";
    collapseBtn.onmouseout = () => collapseBtn.style.background = "transparent";
    topBar.appendChild(collapseBtn);

    // Add to DOM
    const parent = document.querySelector('#blocklyDiv') || document.body;
    parent.appendChild(container);

    // Store size (use saved state if available)
    let storedWidth = originalWidth;
    let storedHeight = originalHeight;
    
    // Restore collapsed state if saved
    let collapsed = savedState.collapsed || false;
    if (collapsed) {
      canvas.style.display = 'none';
      collapseBtn.textContent = "â–²";
    }

    // Function to save current state
    function saveCurrentState() {
      const rect = container.getBoundingClientRect();
      const parent = container.parentElement;
      const parentRect = parent.getBoundingClientRect();
      
      const relativeLeft = rect.left - parentRect.left;
      const relativeTop = rect.top - parentRect.top;
      
      const computedStyle = window.getComputedStyle(container);
      const hasLeft = computedStyle.left !== 'auto' && computedStyle.left !== '';
      const hasTop = computedStyle.top !== 'auto' && computedStyle.top !== '';
      const hasBottom = computedStyle.bottom !== 'auto' && computedStyle.bottom !== '';
      const hasRight = computedStyle.right !== 'auto' && computedStyle.right !== '';
      
      saveMinimapState({
        width: container.offsetWidth,
        height: collapsed ? storedHeight : container.offsetHeight,
        left: hasLeft ? relativeLeft : null,
        top: hasTop ? relativeTop : null,
        bottom: hasBottom ? parseFloat(computedStyle.bottom) : null,
        right: hasRight ? parseFloat(computedStyle.right) : null,
        collapsed: collapsed
      });
    }

    // Collapse/minimize logic
    collapseBtn.onclick = () => {
      collapsed = !collapsed;
      if (collapsed) {
        // Minimize: store current size and hide canvas
        storedWidth = container.offsetWidth;
        storedHeight = container.offsetHeight;
        canvas.style.display = 'none';
        container.style.height = '20px'; // Only show top bar
        container.style.width = storedWidth + 'px'; // Keep width
        collapseBtn.textContent = "â–²";
      } else {
        // Restore: show canvas and restore size
        canvas.style.display = 'block';
        container.style.height = storedHeight + 'px';
        container.style.width = storedWidth + 'px';
        collapseBtn.textContent = "â–¼";
        // Update canvas size to match container
        updateCanvasSize();
      }
      saveCurrentState();
    };

    // Function to update canvas size when container is resized
    function updateCanvasSize() {
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;
      canvas.width = containerWidth;
      canvas.height = Math.max(30, containerHeight - 20); // Subtract top bar height, min 30px
      // Trigger redraw if minimap draw function is available
      if (window.__minimapDrawFunction) {
        window.__minimapDrawFunction();
      }
    }

    // Watch for resize events
    let resizeObserver;
    let resizeTimeout;
    if (window.ResizeObserver) {
      resizeObserver = new ResizeObserver(() => {
        if (!collapsed) {
          updateCanvasSize();
        }
        // Debounce state saving on resize
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          saveCurrentState();
        }, 300);
      });
      resizeObserver.observe(container);
    } else {
      // Fallback: use interval to check size changes
      let lastWidth = container.offsetWidth;
      let lastHeight = container.offsetHeight;
      setInterval(() => {
        if (!collapsed && (container.offsetWidth !== lastWidth || container.offsetHeight !== lastHeight)) {
          lastWidth = container.offsetWidth;
          lastHeight = container.offsetHeight;
          updateCanvasSize();
          saveCurrentState();
        }
      }, 100);
    }

    // Dragging the panel
    let drag = false, sx = 0, sy = 0, sl = 0, st = 0;
    topBar.onmousedown = e => {
      // Don't drag if clicking the collapse button
      if (e.target === collapseBtn || collapseBtn.contains(e.target)) {
        return;
      }
      drag = true;
      sx = e.clientX;
      sy = e.clientY;
      const rect = container.getBoundingClientRect();
      const parent = container.parentElement;
      const parentRect = parent.getBoundingClientRect();
      sl = rect.left - parentRect.left;
      st = rect.top - parentRect.top;
    };
    window.addEventListener('mousemove', e => {
      if (drag) {
        const parent = container.parentElement;
        const parentRect = parent.getBoundingClientRect();
        const newLeft = sl + (e.clientX - sx);
        const newTop = st + (e.clientY - sy);
        container.style.left = newLeft + "px";
        container.style.top = newTop + "px";
        container.style.right = "auto";
        container.style.bottom = "auto";
      }
    });
    window.addEventListener('mouseup', () => {
      if (drag) {
        drag = false;
        saveCurrentState(); // Save position after drag ends
      }
    });

    return canvas;
  }

  function initProMinimap(workspace) {
    console.log("%c[Pro Minimap] Initializing for new workspace...", "color:yellow");

    // Override minimum zoom limit to allow zooming out further
    // Default Blockly minScale is 0.3, we'll allow much lower (e.g., 0.01)
    if (workspace.options && workspace.options.zoomOptions) {
      const originalMinScale = workspace.options.zoomOptions.minScale;
      workspace.options.zoomOptions.minScale = 0.01; // Allow zooming out to 1% of original size
      console.log(\`[Pro Minimap] Overrode minScale from \${originalMinScale} to 0.01\`);
    }

    const canvas = injectUI();
    const ctx = canvas.getContext('2d');
    
    // Store canvas reference globally for resize handler
    window.__minimapCanvas = canvas;
    window.__minimapDrawFunction = null; // Will be set below

    let draggingViewport = false;
    let dragOffsetX = 0, dragOffsetY = 0;
    let scale = 0.1;
    let bounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    let viewportRect = { x: 0, y: 0, w: 0, h: 0 };

    // Helper function to check if a block is visible in the workspace
    // Respects collapsed state - hides children of collapsed blocks
    function isBlockVisible(block) {
      if (!block) return false;
      
      // Check the actual SVG element's display style (most reliable)
      // This directly reflects what Blockly sets when hiding blocks
      try {
        if (block.rendered && block.getSvgRoot) {
          const svgRoot = block.getSvgRoot();
          if (svgRoot) {
            // Check both inline style and computed style
            const inlineDisplay = svgRoot.style.display;
            if (inlineDisplay === 'none') {
              return false;
            }
            
            // Also check computed style as fallback
            const computedDisplay = window.getComputedStyle(svgRoot).display;
            if (computedDisplay === 'none') {
              return false;
            }
          }
        }
      } catch (e) {
        // Fallback to other checks if SVG check fails
      }
      
      // Traverse up the parent chain to check if any ancestor is collapsed
      let current = block;
      while (current) {
        const parent = current.getParent && current.getParent();
        if (!parent) {
          // Reached top level, block is visible (if SVG check passed)
          return true;
        }
        
        // Check if parent is collapsed - this hides all children
        if (typeof parent.isCollapsed === 'function' && parent.isCollapsed()) {
          return false; // Parent is collapsed, so this block is hidden
        }
        
        // Check if the parent input that connects to this block is visible
        const parentInput = parent.getInputWithBlock && parent.getInputWithBlock(current);
        if (parentInput && typeof parentInput.isVisible === 'function') {
          if (!parentInput.isVisible()) {
            return false; // Parent input is hidden (collapsed), so block is hidden
          }
        }
        
        // Check statement chains (previous/next connections)
        // If block is connected via previous connection, check if parent's statement input is visible
        if (current.previousConnection && current.previousConnection.targetBlock) {
          const targetBlock = current.previousConnection.targetBlock();
          if (targetBlock === parent) {
            // This is a statement chain - check if parent has a statement input and if it's visible
            // When collapsed, statement inputs are hidden
            const statementInput = parent.getFirstStatementConnection && parent.getFirstStatementConnection();
            if (statementInput && statementInput.targetBlock) {
              // Check if the statement input's connection is visible
              // Actually, we already checked parent.isCollapsed above, so this should be covered
            }
          }
        }
        
        // Move up the chain
        current = parent;
      }
      
      // Default to visible if we can't determine
      return true;
    }

    function calculateBounds() {
      const allBlocks = workspace.getAllBlocks(false);
      // Filter to only visible blocks
      const blocks = allBlocks.filter(b => isBlockVisible(b));
      if (blocks.length === 0) { bounds = {minX:0,minY:0,maxX:500,maxY:500}; return; }
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      blocks.forEach(b => {
        const p=b.getRelativeToSurfaceXY(); const s=b.getHeightWidth();
        minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
        maxX=Math.max(maxX,p.x+s.width); maxY=Math.max(maxY,p.y+s.height);
      });
      bounds={minX,minY,maxX,maxY};
      const w=maxX-minX, h=maxY-minY;
      scale=Math.min(canvas.width/(w+200), canvas.height/(h+200));
    }

    function drawMinimap() {
      calculateBounds();
      
      // Get view metrics in workspace coordinates (same coordinate system as blocks)
      const metricsManager = workspace.getMetricsManager && workspace.getMetricsManager();
      let viewMetrics;
      if (metricsManager && typeof metricsManager.getViewMetrics === 'function') {
        // Get view metrics in workspace coordinates
        viewMetrics = metricsManager.getViewMetrics(true);
      } else {
        // Fallback: use getMetrics and convert from pixel to workspace coordinates
        const metrics = workspace.getMetrics();
        const zoom = workspace.scale;
        viewMetrics = {
          left: metrics.viewLeft / zoom,
          top: metrics.viewTop / zoom,
          width: metrics.viewWidth / zoom,
          height: metrics.viewHeight / zoom
        };
      }

      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Only draw visible blocks (matches what's shown in workspace)
      workspace.getAllBlocks(false).forEach(block=>{
        // Skip blocks that aren't visible (e.g., children of collapsed blocks)
        if (!isBlockVisible(block)) {
          return;
        }
        
        const pos=block.getRelativeToSurfaceXY();
        const size=block.getHeightWidth();
        
        // Check if block is collapsed
        const isCollapsed = typeof block.isCollapsed === 'function' && block.isCollapsed();
        
        // Get block color
        const blockColor = block.getColour ? block.getColour() : "#00ffcc";
        
        // Draw collapsed blocks differently
        if (isCollapsed) {
          // Collapsed blocks: darker color, dashed border, smaller opacity
          ctx.fillStyle = blockColor;
          ctx.globalAlpha = 0.3; // More transparent
          const x = (pos.x-bounds.minX)*scale;
          const y = (pos.y-bounds.minY)*scale;
          const w = size.width*scale;
          const h = size.height*scale;
          ctx.fillRect(x, y, w, h);
          
          // Draw dashed border to indicate collapsed state
          ctx.globalAlpha = 0.8;
          ctx.strokeStyle = blockColor;
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]); // Dashed line
          ctx.strokeRect(x, y, w, h);
          ctx.setLineDash([]); // Reset to solid
        } else {
          // Normal blocks: regular appearance
          ctx.fillStyle = blockColor;
          ctx.globalAlpha = 0.6;
          ctx.fillRect((pos.x-bounds.minX)*scale,(pos.y-bounds.minY)*scale,size.width*scale,size.height*scale);
        }
      });

      // Draw viewport rectangle in workspace coordinates
      ctx.globalAlpha=1;
      ctx.strokeStyle='#ff4444';
      ctx.lineWidth=2;
      const vx=(viewMetrics.left-bounds.minX)*scale;
      const vy=(viewMetrics.top-bounds.minY)*scale;
      const vw=viewMetrics.width*scale;
      const vh=viewMetrics.height*scale;
      viewportRect={x:vx,y:vy,w:vw,h:vh};
      ctx.strokeRect(vx,vy,vw,vh);
    }

    function moveTo(mx,my){
      // Get view metrics in workspace coordinates
      const metricsManager = workspace.getMetricsManager && workspace.getMetricsManager();
      let viewMetrics;
      if (metricsManager && typeof metricsManager.getViewMetrics === 'function') {
        viewMetrics = metricsManager.getViewMetrics(true);
      } else {
        const metrics = workspace.getMetrics();
        const zoom = workspace.scale;
        viewMetrics = {
          width: metrics.viewWidth / zoom,
          height: metrics.viewHeight / zoom
        };
      }
      
      // Convert minimap click position to workspace coordinates
      const workspaceX = (mx / scale) + bounds.minX;
      const workspaceY = (my / scale) + bounds.minY;
      
      // Calculate scroll position to center viewport on clicked position
      const scrollX = workspaceX - (viewMetrics.width / 2);
      const scrollY = workspaceY - (viewMetrics.height / 2);
      
      // Scroll workspace (scroll expects pixel coordinates, so convert back)
      const zoom = workspace.scale;
      workspace.scroll(-scrollX * zoom, -scrollY * zoom);
      drawMinimap();
    }

    canvas.addEventListener('mousedown',e=>{
      const mx=e.offsetX,my=e.offsetY;
      if(mx>=viewportRect.x&&mx<=viewportRect.x+viewportRect.w&&my>=viewportRect.y&&my<=viewportRect.y+viewportRect.h){
        draggingViewport=true;
        dragOffsetX=mx-viewportRect.x;
        dragOffsetY=my-viewportRect.y;
      } else moveTo(mx,my);
    });
    canvas.addEventListener('mousemove',e=>{
      if(draggingViewport) moveTo(e.offsetX-dragOffsetX+viewportRect.w/2,e.offsetY-dragOffsetY+viewportRect.h/2);
    });
    window.addEventListener('mouseup',()=>draggingViewport=false);

    let redrawPending=false;
    workspace.addChangeListener(()=>{
      if(!redrawPending){redrawPending=true;requestAnimationFrame(()=>{drawMinimap();redrawPending=false;});}
    });

    // Store draw function globally for resize handler
    window.__minimapDrawFunction = drawMinimap;

    drawMinimap();
    console.log("%c[Pro Minimap] âœ… Ready for workspace! (Resizable and minimizable)", "color:lime;font-weight:bold;");
  }

  waitForBlockly();
})();`;
}
</script>
