<template color="#de3900">
    <dummy>
        <label>Add Menu (Shift+A)</label>
    </dummy>
</template>

<script>
function code(block) {
    return `// Track mouse position
let lastMouseX = 0;
let lastMouseY = 0;

document.addEventListener('mousemove', function(e) {
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});

// Define favorite blocks
const favoriteBlocks = [
  'controls_if',
  'logic_compare',
  'math_number',
  'text',
  'variables_get',
  'variables_set',
  'controls_repeat_ext',
  'logic_operation',
  'math_arithmetic'
];

// Helper function to check if we should run multi-selection functionality
function shouldRunMultiSelection() {
  const params = new URLSearchParams(window.location.search);
  return params.has('logic');
}

// Helper function to get all block types
function getAllBlockTypes() {
  if (typeof Blockly !== 'undefined' && Blockly.Blocks) {
    return Object.keys(Blockly.Blocks);
  }
  return [];
}

// Helper function to get all variables
function getAllVariables() {
  const workspace = Blockly.getMainWorkspace();
  if (workspace && workspace.getVariableMap) {
    const variableMap = workspace.getVariableMap();
    if (variableMap) {
      return variableMap.getAllVariables().map(variable => ({
        name: variable.name,
        id: variable.getId()
      }));
    }
  }
  return [];
}

// Helper function to get all procedures
function getAllProcedures() {
  const workspace = Blockly.getMainWorkspace();
  if (!workspace) return [];
  
  try {
    // Get all procedure definition blocks
    const noReturnProcedures = workspace.getBlocksByType('procedures_defnoreturn', false);
    const returnProcedures = workspace.getBlocksByType('procedures_defreturn', false);
    const allProcedureBlocks = noReturnProcedures.concat(returnProcedures);
    
    return allProcedureBlocks.map(block => {
      const name = block.getFieldValue('NAME');
      const hasReturn = block.type === 'procedures_defreturn';
      
      // Get parameters from the procedure block
      let parameters = [];
      try {
        // Look for parameter fields in the procedure block
        const paramFields = block.inputList
          .filter(input => input.name === 'PARAMS')
          .flatMap(input => input.fieldRow || [])
          .filter(field => field.name && field.name.startsWith('PARAM'));
        
        parameters = paramFields.map(field => field.getValue() || field.getText());
      } catch (e) {
        // If we can't get parameters, just use empty array
        parameters = [];
      }
      
      return {
        name: name,
        id: name, // Use name as ID since we don't have a separate ID
        hasReturn: hasReturn,
        parameters: parameters
      };
    });
  } catch (error) {
    console.warn('Failed to get procedures:', error);
    return [];
  }
}

// Helper function to create a block at cursor position
function createBlockAtCursor(type, variableId = null) {
  const fakeMouseEvent = { clientX: lastMouseX, clientY: lastMouseY, button: 0 };
  const workspace = Blockly.getMainWorkspace();
  if (!workspace) return null;

  try {
    const block = workspace.newBlock(type);
    block.initSvg();
    if (variableId) block.setFieldValue(variableId, 'VAR');

    const pt = Blockly.browserEvents.mouseToSvg(fakeMouseEvent, workspace.getParentSvg(), workspace.getInverseScreenCTM());
    const origin = workspace.getOriginOffsetInPixels();
    const workspaceX = (pt.x - origin.x) / workspace.scale;
    const workspaceY = (pt.y - origin.y) / workspace.scale;

    block.moveBy(workspaceX, workspaceY);
    block.render();
    block.select();
    console.log('Created block: ' + type + (variableId ? ' (var: ' + variableId + ')' : ''));
    return block;
  } catch (err) {
    console.warn('Failed to create block ' + type + ':', err);
    return null;
  }
}

// Constants for configuration
const MAX_RESULTS = 15;
const MAX_VARIABLES = 5;
const MAX_HEIGHT = 300;

// Block database - loaded from external file
let blockDatabase = null;

// Load block database from global variable
function loadBlockDatabase() {
  // Use the globally loaded database from init.plug
  if (window.BLOCK_DATABASE) {
    blockDatabase = window.BLOCK_DATABASE;
    console.log('✅ Using globally loaded block database');
  } else {
    console.warn('❌ Global block database not available, using fallback');
    blockDatabase = { blocks: {}, categories: {} };
  }
}

// Helper function to get block info from database
function getBlockInfo(blockType) {
  if (!blockDatabase || !blockDatabase.blocks) {
    return {
      category: 'Advanced',
      displayName: blockType,
      searchTerms: [blockType],
      description: 'Block of type ' + blockType
    };
  }
  
  const blockInfo = blockDatabase.blocks[blockType];
  if (blockInfo) {
    return blockInfo;
  }
  
  // Fallback for unknown blocks
  return {
    category: 'Advanced',
    displayName: blockType,
    searchTerms: [blockType],
    description: 'Block of type ' + blockType
  };
}

// Helper function to get category color for a block type
function getBlockCategoryColor(blockType) {
  const blockInfo = getBlockInfo(blockType);
  const category = blockInfo.category;
  
  if (blockDatabase && blockDatabase.categories && blockDatabase.categories[category]) {
    return blockDatabase.categories[category].color || '#0000ff';
  }
  
  // Fallback colors for common categories
  const fallbackColors = {
    'Logic': '#5081b2',
    'Loops': '#50b250',
    'Text': '#50b291',
    'Numbers': '#5060b2',
    'Lists': '#7150b2',
    'Dictionaries': '#006fa5',
    'System': '#b28150',
    'Advanced': '#5845f6',
    'Events': '#b25050',
    'Selectors': '#50b2b2',
    'Objects': '#50b271',
    'Materials': '#50b271',
    'Animation': '#50b271',
    'Cameras/Lights': '#50b271',
    'Scenes': '#e96868',
    'Time': '#6565dd',
    'HTML': '#b26850',
    'AR/VR': '#b122c4',
    'Audio/Video': '#b2a250',
    'Physics': '#5f636e',
    'Post-processing': '#5c145b'
  };
  
  return fallbackColors[category] || '#0000ff';
}

// Helper function to get category name for a block type
function getBlockCategory(blockType) {
  const blockInfo = getBlockInfo(blockType);
  return blockInfo.category;
}

// Helper function to get display name for a block type
function getBlockDisplayName(blockType) {
  const blockInfo = getBlockInfo(blockType);
  return blockInfo.displayName || blockType;
}

// Load Fuse.js if not already loaded
function loadFuseJS() {
  if (window.Fuse) {
    return Promise.resolve(window.Fuse);
  }
  
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js';
    script.onload = () => resolve(window.Fuse);
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

// Initialize Fuse.js instances
let blockFuse = null;
let variableFuse = null;
let procedureFuse = null;

// Initialize Fuse.js search instances
async function initializeFuseSearch() {
  try {
    const Fuse = await loadFuseJS();
    
    // Configure Fuse.js options for blocks
    const blockFuseOptions = {
      keys: [
        { name: 'displayName', weight: 0.7 },
        { name: 'searchTerms', weight: 0.5 },
        { name: 'description', weight: 0.3 },
        { name: 'id', weight: 0.2 }
      ],
      threshold: 0.3,
      distance: 100,
      includeScore: true,
      includeMatches: true,
      minMatchCharLength: 1,
      findAllMatches: false,
      useExtendedSearch: false
    };
    
    // Configure Fuse.js options for variables
    const variableFuseOptions = {
      keys: [
        { name: 'name', weight: 1.0 }
      ],
      threshold: 0.2,
      distance: 50,
      includeScore: true,
      includeMatches: true,
      minMatchCharLength: 1,
      findAllMatches: false,
      useExtendedSearch: false
    };
    
    // Create searchable data for blocks
    if (blockDatabase && blockDatabase.blocks) {
      const blockData = Object.entries(blockDatabase.blocks).map(([blockType, blockInfo]) => ({
        id: blockType,
        displayName: blockInfo.displayName,
        searchTerms: blockInfo.searchTerms || [],
        description: blockInfo.description || '',
        category: blockInfo.category,
        color: getBlockCategoryColor(blockType)
      }));
      blockFuse = new Fuse(blockData, blockFuseOptions);
    }
    
         // Create searchable data for variables
     const allVariables = getAllVariables();
     if (allVariables.length > 0) {
       variableFuse = new Fuse(allVariables, variableFuseOptions);
     }
     
     // Configure Fuse.js options for procedures
     const procedureFuseOptions = {
       keys: [
         { name: 'name', weight: 1.0 },
         { name: 'parameters', weight: 0.3 }
       ],
       threshold: 0.2,
       distance: 50,
       includeScore: true,
       includeMatches: true,
       minMatchCharLength: 1,
       findAllMatches: false,
       useExtendedSearch: false
     };
     
     // Create searchable data for procedures
     const allProcedures = getAllProcedures();
     if (allProcedures.length > 0) {
       procedureFuse = new Fuse(allProcedures, procedureFuseOptions);
     }
    
    console.log('✅ Fuse.js initialized successfully');
  } catch (error) {
    console.warn('❌ Failed to load Fuse.js, falling back to basic search:', error);
    blockFuse = null;
    variableFuse = null;
  }
}

// Enhanced search function that uses Fuse.js for fuzzy search
function searchBlocks(query) {
  if (!blockFuse) {
    // Fallback to basic search if Fuse.js is not available
    return searchBlocksFallback(query);
  }
  
  const searchTerm = query.trim();
  if (searchTerm === '') {
    return [];
  }
  
  try {
    const results = blockFuse.search(searchTerm);
    
    return results
      .map(result => ({
        id: result.item.id,
        displayName: result.item.displayName,
        category: result.item.category,
        color: result.item.color,
        description: result.item.description,
        score: result.score,
        matches: result.matches
      }))
      .sort((a, b) => {
        // Sort by Fuse.js score (lower is better)
        if (a.score !== b.score) {
          return a.score - b.score;
        }
        
        // Then sort by display name
        return a.displayName.localeCompare(b.displayName);
      });
  } catch (error) {
    console.warn('Fuse.js search failed, falling back to basic search:', error);
    return searchBlocksFallback(query);
  }
}

// Fallback search function for when Fuse.js is not available
function searchBlocksFallback(query) {
  if (!blockDatabase || !blockDatabase.blocks) {
    return [];
  }
  
  const searchTerm = query.toLowerCase();
  const results = [];
  
  for (const [blockType, blockInfo] of Object.entries(blockDatabase.blocks)) {
    const searchTexts = [
      blockInfo.displayName,
      ...(blockInfo.searchTerms || []),
      blockInfo.description || '',
      blockType
    ];
    
    // Check if any search text matches
    const hasMatch = searchTexts.some(text => 
      text.toLowerCase().includes(searchTerm)
    );
    
    if (hasMatch) {
      results.push({
        id: blockType,
        displayName: blockInfo.displayName,
        category: blockInfo.category,
        color: getBlockCategoryColor(blockType),
        description: blockInfo.description,
        score: 0.5 // Default score for fallback
      });
    }
  }
  
  return results.sort((a, b) => {
    // Prioritize exact matches
    const aExact = a.displayName.toLowerCase() === searchTerm || a.id.toLowerCase() === searchTerm;
    const bExact = b.displayName.toLowerCase() === searchTerm || b.id.toLowerCase() === searchTerm;
    
    if (aExact && !bExact) return -1;
    if (!aExact && bExact) return 1;
    
    // Then sort by display name
    return a.displayName.localeCompare(b.displayName);
  });
}

// Fallback search function for variables when Fuse.js is not available
function searchVariablesFallback(variables, searchTerm) {
  return variables
    .filter(variable => 
      variable.name.toLowerCase().includes(searchTerm.toLowerCase())
    )
    .map(variable => ({
      ...variable,
      score: 0.5 // Default score for fallback
    }))
    .sort((a, b) => {
      // Prioritize exact matches
      const aExact = a.name.toLowerCase() === searchTerm.toLowerCase();
      const bExact = b.name.toLowerCase() === searchTerm.toLowerCase();
      
      if (aExact && !bExact) return -1;
      if (!aExact && bExact) return 1;
      
      // Then sort by name
      return a.name.localeCompare(b.name);
    })
    .slice(0, MAX_VARIABLES);
}

// Fallback search function for procedures when Fuse.js is not available
function searchProceduresFallback(procedures, searchTerm) {
  return procedures
    .filter(procedure => 
      procedure.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      procedure.parameters.some(param => param.toLowerCase().includes(searchTerm.toLowerCase()))
    )
    .map(procedure => ({
      ...procedure,
      score: 0.5 // Default score for fallback
    }))
    .sort((a, b) => {
      // Prioritize exact matches
      const aExact = a.name.toLowerCase() === searchTerm.toLowerCase();
      const bExact = b.name.toLowerCase() === searchTerm.toLowerCase();
      
      if (aExact && !bExact) return -1;
      if (!aExact && bExact) return 1;
      
      // Then sort by name
      return a.name.localeCompare(b.name);
    })
    .slice(0, MAX_VARIABLES);
}

// Create and show favorites popup
async function showFavoritesPopup() {
  // Check if we should run this functionality
  if (!shouldRunMultiSelection()) {
    console.log('Favorites popup disabled - logic parameter not found in URL');
    return;
  }
  
  // Load database if not already loaded
  if (!blockDatabase) {
    loadBlockDatabase();
  }
  
  // Initialize Fuse.js if not already done
  if (!blockFuse) {
    await initializeFuseSearch();
  }

  // Remove existing popup if any
  const existingPopup = document.getElementById('favorites-popup');
  if (existingPopup) existingPopup.remove();

  const popup = document.createElement('div');
  popup.id = 'favorites-popup';
  popup.style.cssText = 
    'position: fixed;' +
    'top: ' + (lastMouseY + 10) + 'px;' +
    'left: ' + lastMouseX + 'px;' +
    'transform: translateX(-50%);' +
    'width: min(560px, 92vw);' +
    'padding: 28px;' +
    'border-radius: 18px;' +
    'background: linear-gradient(180deg, #101827bf, #0b1324cc);' +
    'border: 1px solid #ffffff22;' +
    'box-shadow: 0 20px 40px rgba(2, 6, 23, .45);' +
    'backdrop-filter: blur(10px) saturate(120%);' +
    'z-index: 10000;' +
    'display: flex;' +
    'flex-direction: column;';

  // Favorites section
  const favoritesContainer = document.createElement('div');
  favoritesContainer.style.cssText = 
    'display: flex;' +
    'flex-wrap: wrap;' +
    'gap: 12px;' +
    'margin-top: 18px;';

  const favoritesLabel = document.createElement('div');
  favoritesLabel.textContent = 'Quick Favorites';
  favoritesLabel.style.cssText = 
    'color: #e5e7eb;' +
    'font-size: clamp(18px, 2.2vw, 22px);' +
    'line-height: 1.25;' +
    'margin: 0 0 6px;' +
    'font-weight: 700;' +
    'font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;' +
    'width: 100%;';
  popup.appendChild(favoritesLabel);

  // Keyboard navigation state
  let selectedIndex = -1;
  let allButtons = [];
  
  // Function to update button selection
  function updateSelection() {
    allButtons.forEach((button, index) => {
      const categoryColor = button.dataset.categoryColor || '#34d399';
      if (index === selectedIndex) {
        button.style.border = '2px solid #5b8cff';
        button.style.boxShadow = '0 0 0 2px #5b8cff44';
      } else {
        // Reset to original styling
        button.style.border = '1px solid ' + categoryColor + '44';
        button.style.boxShadow = '0 4px 12px ' + categoryColor + '22';
      }
    });
  }
  
  // Add favorite blocks
  favoriteBlocks.forEach((block, index) => {
    const button = document.createElement('button');
    const categoryColor = getBlockCategoryColor(block);
    const categoryName = getBlockCategory(block);
    const displayName = getBlockDisplayName(block);
    const blockInfo = getBlockInfo(block);
    
    button.textContent = displayName;
    button.dataset.categoryColor = categoryColor;
    button.dataset.blockType = block;
    button.style.cssText = 
      'background: linear-gradient(180deg, ' + categoryColor + 'dd, ' + categoryColor + 'bb);' +
      'color: white;' +
      'border: 1px solid ' + categoryColor + '44;' +
      'padding: 12px 16px;' +
      'border-radius: 12px;' +
      'cursor: pointer;' +
      'text-align: left;' +
      'font-size: 14px;' +
      'font-weight: 500;' +
      'transition: transform .06s ease, filter .2s ease, box-shadow .2s ease;' +
      'position: relative;' +
      'flex: 1;' +
      'min-width: 140px;' +
      'box-shadow: 0 4px 12px ' + categoryColor + '22;';
    
    // Add tooltip with description
    if (blockInfo.description) {
      button.title = blockInfo.description;
    }
    
    // Add category indicator
    const categoryIndicator = document.createElement('span');
    categoryIndicator.textContent = ' ' + categoryName;
    categoryIndicator.style.cssText = 
      'font-size: 12px;' +
      'opacity: 0.7;' +
      'margin-left: 8px;' +
      'font-weight: 400;';
    button.appendChild(categoryIndicator);
    
    button.addEventListener('mouseenter', () => {
      if (selectedIndex !== allButtons.indexOf(button)) {
        button.style.filter = 'brightness(1.1)';
        button.style.transform = 'translateY(-1px)';
        button.style.boxShadow = '0 8px 20px ' + categoryColor + '33';
      }
    });
    
    button.addEventListener('mouseleave', () => {
      if (selectedIndex !== allButtons.indexOf(button)) {
        button.style.filter = 'brightness(1)';
        button.style.transform = 'translateY(0)';
        button.style.boxShadow = '0 4px 12px ' + categoryColor + '22';
      }
    });
    
    button.addEventListener('mousedown', () => {
      button.style.transform = 'translateY(0px)';
    });
    
    button.addEventListener('click', () => {
      createBlockAtCursor(block);
      popup.remove();
    });
    
    favoritesContainer.appendChild(button);
    allButtons.push(button);
  });
  
  // Set initial selection
  if (allButtons.length > 0) {
    selectedIndex = 0;
    updateSelection();
  }

  popup.appendChild(favoritesContainer);
  document.body.appendChild(popup);

  // Close when clicking outside
  document.addEventListener('click', function closeOnOutsideClick(e) {
    if (!popup.contains(e.target)) {
      popup.remove();
    }
  }, { once: true });

  // Keyboard navigation and selection
  function handleKeyboard(e) {
    if (e.key === 'Escape' && document.getElementById('favorites-popup')) {
      popup.remove();
      document.removeEventListener('keydown', handleKeyboard);
      return;
    }
    
    // Handle arrow key navigation
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (allButtons.length > 0) {
        selectedIndex = (selectedIndex + 1) % allButtons.length;
        updateSelection();
      }
      return;
    }
    
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (allButtons.length > 0) {
        selectedIndex = selectedIndex <= 0 ? allButtons.length - 1 : selectedIndex - 1;
        updateSelection();
      }
      return;
    }
    
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      if (allButtons.length > 0) {
        // Simple left navigation - go to previous item
        selectedIndex = selectedIndex <= 0 ? allButtons.length - 1 : selectedIndex - 1;
        updateSelection();
      }
      return;
    }
    
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      if (allButtons.length > 0) {
        // Simple right navigation - go to next item
        selectedIndex = (selectedIndex + 1) % allButtons.length;
        updateSelection();
      }
      return;
    }
    
    // Handle Enter key selection
    if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0 && selectedIndex < allButtons.length) {
        const selectedButton = allButtons[selectedIndex];
        const blockType = selectedButton.dataset.blockType;
        createBlockAtCursor(blockType);
        popup.remove();
        document.removeEventListener('keydown', handleKeyboard);
      }
      return;
    }
  }
  
  document.addEventListener('keydown', handleKeyboard);
}

// Create and show search popup
async function showSearchPopup() {
  // Check if we should run this functionality
  if (!shouldRunMultiSelection()) {
    console.log('Search popup disabled - logic parameter not found in URL');
    return;
  }
  
  // Load database if not already loaded
  if (!blockDatabase) {
    loadBlockDatabase();
  }
  
  // Initialize Fuse.js if not already done
  if (!blockFuse) {
    await initializeFuseSearch();
  }

  // Remove existing popup if any
  const existingPopup = document.getElementById('block-search-popup');
  if (existingPopup) existingPopup.remove();

  const popup = document.createElement('div');
  popup.id = 'block-search-popup';
  popup.style.cssText = 
    'position: fixed;' +
    'top: ' + (lastMouseY + 10) + 'px;' +
    'left: ' + lastMouseX + 'px;' +
    'transform: translateX(-50%);' +
    'width: min(560px, 92vw);' +
    'padding: 28px;' +
    'border-radius: 18px;' +
    'background: linear-gradient(180deg, #101827bf, #0b1324cc);' +
    'border: 1px solid #ffffff22;' +
    'box-shadow: 0 20px 40px rgba(2, 6, 23, .45);' +
    'backdrop-filter: blur(10px) saturate(120%);' +
    'z-index: 10000;' +
    'max-height: 500px;' +
    'display: flex;' +
    'flex-direction: column;';

  // Add title above search field
  const searchTitle = document.createElement('div');
  searchTitle.textContent = 'Add block';
  searchTitle.style.cssText = 
    'color: #e5e7eb;' +
    'font-size: clamp(18px, 2.2vw, 22px);' +
    'line-height: 1.25;' +
    'margin: 0 0 12px;' +
    'font-weight: 700;' +
    'font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;' +
    'width: 100%;';
  popup.appendChild(searchTitle);

  // Search input
  const searchInput = document.createElement('input');
  searchInput.type = 'text';
  searchInput.placeholder = 'Search for blocks...';
  searchInput.style.cssText = 
    'background: linear-gradient(180deg, #0c1322, #0a111e);' +
    'color: #e6f0ff;' +
    'border: 1px solid #ffffff1a;' +
    'border-radius: 14px;' +
    'padding: 14px;' +
    'font-size: 16px;' +
    'font-weight: 500;' +
    'font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;' +
    'margin-bottom: 18px;' +
    'width: 100%;' +
    'box-sizing: border-box;' +
    'box-shadow: inset 0 0 0 1px #00000040;' +
    'outline: none;' +
    'transition: border-color .2s ease;';

  // Automatically focus the search input when popup is shown
  setTimeout(() => searchInput.focus(), 0);
  
  // Add focus styles
  searchInput.addEventListener('focus', () => {
    searchInput.style.borderColor = '#5b8cff';
    searchInput.style.boxShadow = '0 0 0 3px #5b8cff22';
  });
  
  searchInput.addEventListener('blur', () => {
    searchInput.style.borderColor = '#ffffff1a';
    searchInput.style.boxShadow = 'inset 0 0 0 1px #00000040';
  });

  // Results container
  const resultsContainer = document.createElement('div');
  resultsContainer.id = 'search-results';
  resultsContainer.style.cssText = 
    'max-height: ' + MAX_HEIGHT + 'px;' +
    'overflow-y: auto;' +
    'display: flex;' +
    'flex-direction: column;' +
    'gap: 8px;' +
    'padding-right: 4px;' +
    'scrollbar-width: thin;' +
    'scrollbar-color: #4b5563 #1f2937;';
  
  // Add custom scrollbar styles for webkit browsers
  const scrollbarStyles = document.createElement('style');
  scrollbarStyles.textContent = 
    '#search-results::-webkit-scrollbar {' +
    '  width: 8px;' +
    '}' +
    '#search-results::-webkit-scrollbar-track {' +
    '  background: #1f2937;' +
    '  border-radius: 4px;' +
    '}' +
    '#search-results::-webkit-scrollbar-thumb {' +
    '  background: linear-gradient(180deg, #4b5563, #374151);' +
    '  border-radius: 4px;' +
    '  border: 1px solid #374151;' +
    '}' +
    '#search-results::-webkit-scrollbar-thumb:hover {' +
    '  background: linear-gradient(180deg, #6b7280, #4b5563);' +
    '}' +
    '#search-results::-webkit-scrollbar-thumb:active {' +
    '  background: linear-gradient(180deg, #9ca3af, #6b7280);' +
    '}';
  document.head.appendChild(scrollbarStyles);

  // Keyboard navigation state
  let selectedIndex = -1;
  let allButtons = [];
  
  // Function to update button selection
  function updateSelection() {
    allButtons.forEach((button, index) => {
      if (index === selectedIndex) {
        button.style.border = '2px solid #5b8cff';
        button.style.boxShadow = '0 0 0 2px #5b8cff44';
        button.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      } else {
        // Reset to original styling
        const categoryColor = button.dataset.categoryColor || '#34d399';
        button.style.border = '1px solid ' + categoryColor + '44';
        button.style.boxShadow = '0 4px 12px ' + categoryColor + '22';
      }
    });
  }
  
     // Function to filter and display results
   function updateResults() {
     const searchTerm = searchInput.value.toLowerCase();
     resultsContainer.innerHTML = '';
     allButtons = [];
     selectedIndex = -1;
     
     // Clear any existing create buttons from previous searches
     const existingCreateButtons = popup.querySelectorAll('[data-action="create-variable"], [data-action="create-procedure"]');
     existingCreateButtons.forEach(button => {
       if (button.parentElement) {
         button.parentElement.remove();
       }
     });
    
                   // Use enhanced search function
      const searchResults = searchBlocks(searchTerm).slice(0, MAX_RESULTS);
    
               // Filter variables with Fuse.js
      let filteredVariables = [];
      const allVariables = getAllVariables(); // Get fresh variables
      if (variableFuse && allVariables.length > 0) {
        try {
          // Update the Fuse instance with fresh data
          variableFuse.setCollection(allVariables);
          const variableResults = variableFuse.search(searchTerm);
          filteredVariables = variableResults
            .map(result => ({
              ...result.item,
              score: result.score
            }))
            .slice(0, MAX_VARIABLES);
        } catch (error) {
          console.warn('Variable Fuse.js search failed, using fallback:', error);
          filteredVariables = searchVariablesFallback(allVariables, searchTerm);
        }
      } else {
        filteredVariables = searchVariablesFallback(allVariables, searchTerm);
      }
       
               // Filter procedures with Fuse.js
        let filteredProcedures = [];
        const allProcedures = getAllProcedures(); // Get fresh procedures
        if (procedureFuse && allProcedures.length > 0) {
          try {
            // Update the Fuse instance with fresh data
            procedureFuse.setCollection(allProcedures);
            const procedureResults = procedureFuse.search(searchTerm);
            filteredProcedures = procedureResults
              .map(result => ({
                ...result.item,
                score: result.score
              }))
              .slice(0, MAX_VARIABLES);
          } catch (error) {
            console.warn('Procedure Fuse.js search failed, using fallback:', error);
            filteredProcedures = searchProceduresFallback(allProcedures, searchTerm);
          }
        } else {
          filteredProcedures = searchProceduresFallback(allProcedures, searchTerm);
        }
     
                                                                       
    
         // Combine and sort all results by relevance
     const allResults = [];
     
     // Add blocks with their scores
     searchResults.forEach(block => {
       allResults.push({
         type: 'block',
         data: block,
         score: block.score || 0.5
       });
     });
     
            // Add variables with their scores
       filteredVariables.forEach(variable => {
         allResults.push({
           type: 'variable',
           data: variable,
           score: variable.score || 0.5
         });
       });
       
       // Add procedures with their scores
       filteredProcedures.forEach(procedure => {
         allResults.push({
           type: 'procedure',
           data: procedure,
           score: procedure.score || 0.5
         });
       });
     
     // Sort by score (lower is better for Fuse.js)
     allResults.sort((a, b) => a.score - b.score);
     
     // Create buttons for all results
     allResults.forEach(result => {
       const button = document.createElement('button');
       
       if (result.type === 'block') {
         const block = result.data;
         const categoryColor = block.color;
         const categoryName = block.category;
         
         button.textContent = block.displayName;
         button.dataset.categoryColor = categoryColor;
         button.dataset.blockType = block.id;
         button.dataset.isVariable = 'false';
         button.style.cssText = 
           'background: linear-gradient(180deg, ' + categoryColor + 'dd, ' + categoryColor + 'bb);' +
           'color: white;' +
           'border: 1px solid ' + categoryColor + '44;' +
           'padding: 12px 16px;' +
           'border-radius: 12px;' +
           'cursor: pointer;' +
           'text-align: left;' +
           'font-size: 14px;' +
           'font-weight: 500;' +
           'transition: transform .06s ease, filter .2s ease, box-shadow .2s ease;' +
           'position: relative;' +
           'box-shadow: 0 4px 12px ' + categoryColor + '22;';
         
         // Add tooltip with description
         if (block.description) {
           button.title = block.description;
         }
         
         // Add category indicator
         const categoryIndicator = document.createElement('span');
         categoryIndicator.textContent = ' ' + categoryName;
         categoryIndicator.style.cssText = 
           'font-size: 12px;' +
           'opacity: 0.7;' +
           'margin-left: 8px;' +
           'font-weight: 400;';
         button.appendChild(categoryIndicator);
         
         button.addEventListener('mouseenter', () => {
           if (selectedIndex !== allButtons.indexOf(button)) {
             button.style.filter = 'brightness(1.1)';
             button.style.transform = 'translateY(-1px)';
             button.style.boxShadow = '0 8px 20px ' + categoryColor + '33';
           }
         });
         
         button.addEventListener('mouseleave', () => {
           if (selectedIndex !== allButtons.indexOf(button)) {
             button.style.filter = 'brightness(1)';
             button.style.transform = 'translateY(0)';
             button.style.boxShadow = '0 4px 12px ' + categoryColor + '22';
           }
         });
         
         button.addEventListener('mousedown', () => {
           button.style.transform = 'translateY(0px)';
         });
         
         button.addEventListener('click', () => {
           createBlockAtCursor(block.id);
           popup.remove();
         });
               } else if (result.type === 'variable') {
          // Variable result
          const variable = result.data;
          const isCreateOption = variable.isCreateOption;
         
                   button.textContent = variable.name;
          button.dataset.categoryColor = isCreateOption ? '#f59e0b' : '#b14f80';
          button.dataset.variableId = variable.id;
          button.dataset.isVariable = 'true';
          button.dataset.isCreateOption = isCreateOption ? 'true' : 'false';
          if (isCreateOption) {
            button.dataset.originalName = variable.originalName;
          }
          
          const buttonColor = isCreateOption ? '#f59e0b' : '#b14f80';
         button.style.cssText = 
           'background: linear-gradient(180deg, ' + buttonColor + 'dd, ' + buttonColor + 'bb);' +
           'color: white;' +
           'border: 1px solid ' + buttonColor + '44;' +
           'padding: 12px 16px;' +
           'border-radius: 12px;' +
           'cursor: pointer;' +
           'text-align: left;' +
           'font-size: 14px;' +
           'font-weight: 500;' +
           'transition: transform .06s ease, filter .2s ease, box-shadow .2s ease;' +
           'box-shadow: 0 4px 12px ' + buttonColor + '22;';
         
         button.addEventListener('mouseenter', () => {
           if (selectedIndex !== allButtons.indexOf(button)) {
             button.style.filter = 'brightness(1.1)';
             button.style.transform = 'translateY(-1px)';
             button.style.boxShadow = '0 8px 20px ' + buttonColor + '33';
           }
         });
         
         button.addEventListener('mouseleave', () => {
           if (selectedIndex !== allButtons.indexOf(button)) {
             button.style.filter = 'brightness(1)';
             button.style.transform = 'translateY(0)';
             button.style.boxShadow = '0 4px 12px ' + buttonColor + '22';
           }
         });
         
         button.addEventListener('mousedown', () => {
           button.style.transform = 'translateY(0px)';
         });
         
         button.addEventListener('click', () => {
           if (isCreateOption) {
             // Create a new variable and then create the block
             const workspace = Blockly.getMainWorkspace();
             if (workspace) {
               try {
                 const newVariable = workspace.createVariable(variable.originalName);
                 createBlockAtCursor('variables_get', newVariable.getId());
               } catch (error) {
                 console.warn('Failed to create variable:', error);
                 // Fallback: try to create the block anyway
                 createBlockAtCursor('variables_get');
               }
             }
           } else {
             createBlockAtCursor('variables_get', variable.id);
           }
           popup.remove();
         });
       } else if (result.type === 'procedure') {
         // Procedure result
         const procedure = result.data;
         
         // Create display name with parameters
         const paramText = procedure.parameters.length > 0 ? 
           ' (' + procedure.parameters.join(', ') + ')' : '';
         const returnText = procedure.hasReturn ? ' → ' : '';
         button.textContent = returnText + procedure.name + paramText;
         
         button.dataset.categoryColor = '#8b5cf6';
         button.dataset.procedureId = procedure.id;
         button.dataset.isVariable = 'false';
         button.dataset.isProcedure = 'true';
         
         const buttonColor = '#8b5cf6'; // Purple for procedures
         button.style.cssText = 
           'background: linear-gradient(180deg, ' + buttonColor + 'dd, ' + buttonColor + 'bb);' +
           'color: white;' +
           'border: 1px solid ' + buttonColor + '44;' +
           'padding: 12px 16px;' +
           'border-radius: 12px;' +
           'cursor: pointer;' +
           'text-align: left;' +
           'font-size: 14px;' +
           'font-weight: 500;' +
           'transition: transform .06s ease, filter .2s ease, box-shadow .2s ease;' +
           'box-shadow: 0 4px 12px ' + buttonColor + '22;';
         
         button.addEventListener('mouseenter', () => {
           if (selectedIndex !== allButtons.indexOf(button)) {
             button.style.filter = 'brightness(1.1)';
             button.style.transform = 'translateY(-1px)';
             button.style.boxShadow = '0 8px 20px ' + buttonColor + '33';
           }
         });
         
         button.addEventListener('mouseleave', () => {
           if (selectedIndex !== allButtons.indexOf(button)) {
             button.style.filter = 'brightness(1)';
             button.style.transform = 'translateY(0)';
             button.style.boxShadow = '0 4px 12px ' + buttonColor + '22';
           }
         });
         
         button.addEventListener('mousedown', () => {
           button.style.transform = 'translateY(0px)';
         });
         
                   button.addEventListener('click', () => {
            // Create procedure call block
            const blockType = procedure.hasReturn ? 'procedures_callreturn' : 'procedures_callnoreturn';
            const block = createBlockAtCursor(blockType);
            if (block) {
              // Set the procedure name
              block.setFieldValue(procedure.name, 'NAME');
            }
            popup.remove();
          });
       }
       
       resultsContainer.appendChild(button);
       allButtons.push(button);
     });
    
          // Set initial selection if there are results
      if (allButtons.length > 0) {
        selectedIndex = 0;
        updateSelection();
      }
      
             // Add create variable and procedure buttons if search term is valid
       const originalSearchTerm = searchInput.value.trim();
       if (originalSearchTerm.length > 0 && originalSearchTerm.length <= 50) {
         // Check if it's a valid variable/procedure name (alphanumeric and underscores)
         const isValidName = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(originalSearchTerm);
         if (isValidName) {
           // Check if variable name is already taken
           const existingVariable = allVariables.find(v => 
             v.name.toLowerCase() === originalSearchTerm.toLowerCase()
           );
           
           // Check if procedure name is already taken
           const existingProcedure = allProcedures.find(p => 
             p.name.toLowerCase() === originalSearchTerm.toLowerCase()
           );
           
           // Create container for the buttons
           const createButtonsContainer = document.createElement('div');
           createButtonsContainer.style.cssText = 
             'display: flex;' +
             'gap: 8px;' +
             'margin-top: 12px;' +
             'padding-top: 12px;' +
             'border-top: 1px solid #374151;';
           
                       // Create Variable button (if name not taken)
            if (!existingVariable) {
              const createVarButton = document.createElement('button');
              createVarButton.style.cssText = 
                'background: linear-gradient(180deg, #f59e0bdd, #f59e0bbb);' +
                'color: white;' +
                'border: 1px solid #f59e0b44;' +
                'padding: 10px 14px;' +
                'border-radius: 10px;' +
                'cursor: pointer;' +
                'text-align: left;' +
                'font-size: 13px;' +
                'font-weight: 500;' +
                'transition: transform .06s ease, filter .2s ease, box-shadow .2s ease;' +
                'box-shadow: 0 4px 12px #f59e0b22;' +
                'flex: 1;' +
                'display: flex;' +
                'justify-content: space-between;' +
                'align-items: center;';
              
              // Main text
              const mainText = document.createElement('span');
              mainText.textContent = 'Create Variable "' + originalSearchTerm + '"';
              createVarButton.appendChild(mainText);
              
              // Keyboard shortcut hint
              const shortcutHint = document.createElement('span');
              shortcutHint.textContent = '(Shift+Enter)';
              shortcutHint.style.cssText = 
                'font-size: 11px;' +
                'opacity: 0.6;' +
                'font-weight: 400;' +
                'margin-left: 8px;';
              createVarButton.appendChild(shortcutHint);
              
              createVarButton.dataset.categoryColor = '#f59e0b';
              createVarButton.dataset.action = 'create-variable';
              createVarButton.dataset.originalName = originalSearchTerm;
             
             createVarButton.addEventListener('mouseenter', () => {
               createVarButton.style.filter = 'brightness(1.1)';
               createVarButton.style.transform = 'translateY(-1px)';
               createVarButton.style.boxShadow = '0 8px 20px #f59e0b33';
             });
             
             createVarButton.addEventListener('mouseleave', () => {
               createVarButton.style.filter = 'brightness(1)';
               createVarButton.style.transform = 'translateY(0)';
               createVarButton.style.boxShadow = '0 4px 12px #f59e0b22';
             });
             
             createVarButton.addEventListener('mousedown', () => {
               createVarButton.style.transform = 'translateY(0px)';
             });
             
             createVarButton.addEventListener('click', () => {
               const workspace = Blockly.getMainWorkspace();
               if (workspace) {
                 try {
                   const newVariable = workspace.createVariable(originalSearchTerm);
                   createBlockAtCursor('variables_get', newVariable.getId());
                 } catch (error) {
                   console.warn('Failed to create variable:', error);
                   createBlockAtCursor('variables_get');
                 }
               }
               popup.remove();
             });
             
             createButtonsContainer.appendChild(createVarButton);
           }
           
                       // Create Procedure button (if name not taken)
            if (!existingProcedure) {
              const createProcButton = document.createElement('button');
              createProcButton.style.cssText = 
                'background: linear-gradient(180deg, #8b5cf6dd, #8b5cf6bb);' +
                'color: white;' +
                'border: 1px solid #8b5cf644;' +
                'padding: 10px 14px;' +
                'border-radius: 10px;' +
                'cursor: pointer;' +
                'text-align: left;' +
                'font-size: 13px;' +
                'font-weight: 500;' +
                'transition: transform .06s ease, filter .2s ease, box-shadow .2s ease;' +
                'box-shadow: 0 4px 12px #8b5cf622;' +
                'flex: 1;' +
                'display: flex;' +
                'justify-content: space-between;' +
                'align-items: center;';
              
              // Main text
              const mainText = document.createElement('span');
              mainText.textContent = 'Create Procedure "' + originalSearchTerm + '"';
              createProcButton.appendChild(mainText);
              
              // Keyboard shortcut hint
              const shortcutHint = document.createElement('span');
              shortcutHint.textContent = '(Ctrl+Enter)';
              shortcutHint.style.cssText = 
                'font-size: 11px;' +
                'opacity: 0.6;' +
                'font-weight: 400;' +
                'margin-left: 8px;';
              createProcButton.appendChild(shortcutHint);
              
              createProcButton.dataset.categoryColor = '#8b5cf6';
              createProcButton.dataset.action = 'create-procedure';
              createProcButton.dataset.originalName = originalSearchTerm;
             
             createProcButton.addEventListener('mouseenter', () => {
               createProcButton.style.filter = 'brightness(1.1)';
               createProcButton.style.transform = 'translateY(-1px)';
               createProcButton.style.boxShadow = '0 8px 20px #8b5cf633';
             });
             
             createProcButton.addEventListener('mouseleave', () => {
               createProcButton.style.filter = 'brightness(1)';
               createProcButton.style.transform = 'translateY(0)';
               createProcButton.style.boxShadow = '0 4px 12px #8b5cf622';
             });
             
             createProcButton.addEventListener('mousedown', () => {
               createProcButton.style.transform = 'translateY(0px)';
             });
             
             createProcButton.addEventListener('click', () => {
               // Create a procedure definition block
               const block = createBlockAtCursor('procedures_defnoreturn');
               if (block) {
                 block.setFieldValue(originalSearchTerm, 'NAME');
               }
               popup.remove();
             });
             
             createButtonsContainer.appendChild(createProcButton);
           }
           
           // Only add the container if we have buttons
           if (createButtonsContainer.children.length > 0) {
             popup.appendChild(createButtonsContainer);
           }
         }
       }
    }

  // Initial results
  updateResults();
  
  // Search input event listener
  searchInput.addEventListener('input', updateResults);
  
  // Keyboard navigation and selection
  searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('block-search-popup')) {
      popup.remove();
      return;
    }
    
    // Handle arrow key navigation
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (allButtons.length > 0) {
        selectedIndex = (selectedIndex + 1) % allButtons.length;
        updateSelection();
      }
      return;
    }
    
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (allButtons.length > 0) {
        selectedIndex = selectedIndex <= 0 ? allButtons.length - 1 : selectedIndex - 1;
        updateSelection();
      }
      return;
    }
    
         // Handle Enter key selection
     if (e.key === 'Enter') {
       e.preventDefault();
       
       // Check for Shift+Enter (create variable) or Ctrl+Enter (create procedure)
       const searchTerm = searchInput.value.trim();
       if (searchTerm.length > 0 && searchTerm.length <= 50) {
         const isValidName = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(searchTerm);
         if (isValidName) {
           const allVariables = getAllVariables();
           const allProcedures = getAllProcedures();
           
           const existingVariable = allVariables.find(v => 
             v.name.toLowerCase() === searchTerm.toLowerCase()
           );
           const existingProcedure = allProcedures.find(p => 
             p.name.toLowerCase() === searchTerm.toLowerCase()
           );
           
           if (e.shiftKey && !existingVariable) {
             // Shift+Enter: Create variable
             const workspace = Blockly.getMainWorkspace();
             if (workspace) {
               try {
                 const newVariable = workspace.createVariable(searchTerm);
                 createBlockAtCursor('variables_get', newVariable.getId());
               } catch (error) {
                 console.warn('Failed to create variable:', error);
                 createBlockAtCursor('variables_get');
               }
             }
             popup.remove();
             return;
           }
           
           if (e.ctrlKey && !existingProcedure) {
             // Ctrl+Enter: Create procedure
             const block = createBlockAtCursor('procedures_defnoreturn');
             if (block) {
               block.setFieldValue(searchTerm, 'NAME');
             }
             popup.remove();
             return;
           }
         }
       }
       
       // Regular Enter key selection
       if (selectedIndex >= 0 && selectedIndex < allButtons.length) {
         const selectedButton = allButtons[selectedIndex];
         const isVariable = selectedButton.dataset.isVariable === 'true';
         const isProcedure = selectedButton.dataset.isProcedure === 'true';
         
         if (isVariable) {
           const variableId = selectedButton.dataset.variableId;
           const isCreateOption = selectedButton.dataset.isCreateOption === 'true';
         
         if (isCreateOption) {
           // Create a new variable and then create the block
           const workspace = Blockly.getMainWorkspace();
           if (workspace) {
             try {
               const originalName = selectedButton.dataset.originalName;
               const newVariable = workspace.createVariable(originalName);
               createBlockAtCursor('variables_get', newVariable.getId());
             } catch (error) {
               console.warn('Failed to create variable:', error);
               // Fallback: try to create the block anyway
               createBlockAtCursor('variables_get');
             }
           }
         } else {
           createBlockAtCursor('variables_get', variableId);
         }
       } else if (isProcedure) {
         const procedureName = selectedButton.dataset.procedureId; // This is actually the procedure name
         const hasReturn = selectedButton.textContent.includes(' → ');
         const blockType = hasReturn ? 'procedures_callreturn' : 'procedures_callnoreturn';
         const block = createBlockAtCursor(blockType);
         if (block) {
           // Set the procedure name
           block.setFieldValue(procedureName, 'NAME');
         }
       } else {
         const blockType = selectedButton.dataset.blockType;
         createBlockAtCursor(blockType);
       }
      popup.remove();
    }
      return;
    }
  });

  // Focus the input
  searchInput.focus();

  // Assemble popup
  popup.appendChild(searchInput);
  popup.appendChild(resultsContainer);
  document.body.appendChild(popup);

  // Close when clicking outside
  document.addEventListener('click', function closeOnOutsideClick(e) {
    if (!popup.contains(e.target)) {
      popup.remove();
    }
  }, { once: true });
}

// Add keyboard shortcuts for Q (favorites) and Shift+A (search)
document.addEventListener('keydown', function(e) {
  // Check if we're currently typing in an input field, textarea, or contenteditable element
  const activeElement = document.activeElement;
  const isTyping = activeElement && (
    activeElement.tagName === 'INPUT' ||
    activeElement.tagName === 'TEXTAREA' ||
    activeElement.contentEditable === 'true' ||
    activeElement.isContentEditable
  );
  
  // Only trigger if we're not typing
  if (!isTyping) {
    // Q key for favorites popup
    if (e.key === 'Q' || e.key === 'q') {
      e.preventDefault();
      showFavoritesPopup().catch(err => {
        console.warn('Failed to show favorites popup:', err);
      });
    }
    
    // Shift+A for search popup
    if (e.shiftKey && e.key === 'A') {
      e.preventDefault();
      showSearchPopup().catch(err => {
        console.warn('Failed to show search popup:', err);
      });
    }
  }
});`;
}
</script>
